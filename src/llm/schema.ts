/**
 * Utilities for creating optimized JSON schemas for LLM usage
 */

import type { z } from "zod";
import { zodToJsonSchema } from "zod-to-json-schema";

interface JsonSchema {
	type?: string;
	properties?: Record<string, JsonSchema>;
	items?: JsonSchema;
	anyOf?: JsonSchema[];
	not?: JsonSchema;
	required?: string[];
	additionalProperties?: boolean;
	description?: string;
	default?: any;
	minItems?: number;
	$schema?: string;
	$defs?: Record<string, JsonSchema>;
	$ref?: string;
	[key: string]: any;
}

export class SchemaOptimizer {
	/**
	 * Create the most optimized schema by converting Zod schemas to OpenAI-compatible JSON schemas
	 * while preserving FULL descriptions and ALL action definitions. Also ensures OpenAI strict mode compatibility.
	 *
	 * @param model - The Zod schema to optimize
	 * @returns Optimized schema with all $refs resolved and strict mode compatibility
	 */
	static createOptimizedJsonSchema(model: any): Record<string, any> {
		// Validate input - should not be undefined or null
		if (model === undefined || model === null) {
			throw new Error(
				`--->SchemaOptimizer.createOptimizedJsonSchema() received ${model === null ? "null" : "undefined"} model. A valid Zod schema is required.`,
			);
		}

		try {
			// Generate original schema from various input types
			const originalSchema = this.generateSchemaFromZod(model);
			// console.debug(
			// 	`---->SchemaOptimizer createOptimizedJsonSchema originalSchema:${JSON.stringify(
			// 		originalSchema,
			// 		null,
			// 		2,
			// 	)}`,
			// );

			// Use the conversion method to optimize the schema
			const optimizedSchema = this.convertZodToOpenAI(originalSchema);

			// console.debug(
			// 	`---->SchemaOptimizer createOptimizedJsonSchema optimizedSchema:${JSON.stringify(
			// 		optimizedSchema,
			// 		null,
			// 		2,
			// 	)}`,
			// );
			return optimizedSchema;
		} catch (error) {
			console.error(`Failed to generate optimized JSON schema:`, error);
			throw new Error(
				`Failed to generate optimized JSON schema: ${error instanceof Error ? error.message : String(error)}`,
			);
		}
	}

	/**
	 * Convert Zod-generated JSON Schema to OpenAI JSON Schema format
	 * @param originalSchema - The schema generated by zod-to-json-schema
	 * @returns Optimized schema compatible with OpenAI
	 */
	static convertZodToOpenAI(originalSchema: JsonSchema): JsonSchema {
		const optimized = this.deepClone(originalSchema);

		// Remove $schema from the result (keep it at root level only)
		if (optimized.$schema) {
			delete optimized.$schema;
		}

		// First, resolve all $refs to avoid nested reference issues
		this.resolveRefsInline(optimized);

		// Then optimize the schema
		this.optimizeSchemaRecursive(optimized);

		// Reorder properties to match OpenAI preference
		return this.reorderProperties(optimized);
	}

	/**
	 * Generate JSON schema from various input types
	 * @param model - The schema/model to convert
	 * @returns JSON schema object
	 */
	private static generateSchemaFromZod(model: any): JsonSchema {
		// Check if the input is a valid Zod schema
		if (model && typeof model === "object" && model._def) {
			// Use zod-to-json-schema to convert Zod schema to JSON schema
			const jsonSchema = zodToJsonSchema(model, {
				// Use target draft-7 for better OpenAI compatibility
				target: "jsonSchema7",
				// Avoid $refs by inlining everything
				$refStrategy: "none",
				// Ensure proper property names
				nameStrategy: "title",
			}) as JsonSchema;
			return jsonSchema;
		}

		// Fallback: check for other schema formats
		if (typeof model === "function" && model.getJsonSchema) {
			return model.getJsonSchema();
		}

		if (typeof model === "object" && model.schema) {
			return model.schema;
		}

		// If it's already a JSON schema object, return it
		if (
			model &&
			typeof model === "object" &&
			(model.type || model.properties || model.anyOf)
		) {
			return model;
		}

		throw new Error(
			`Invalid schema provided. Expected a Zod schema, class with getJsonSchema method, or JSON schema object. Received: ${typeof model}`,
		);
	}

	/**
	 * Resolve all $refs inline to avoid nested reference issues that OpenAI doesn't support
	 * @param schema - The schema to process
	 * @param defs - The definitions object containing referenced schemas
	 */
	private static resolveRefsInline(
		schema: JsonSchema,
		defs?: Record<string, JsonSchema>,
	): void {
		if (!schema || typeof schema !== "object") return;

		// Get the definitions from the root if available
		if (!defs && schema.$defs) {
			defs = schema.$defs;
			// Remove $defs from root after capturing it
			delete schema.$defs;
		}

		// If this schema has a $ref, resolve it inline
		if (schema.$ref && defs) {
			const refPath = schema.$ref
				.replace("#/$defs/", "")
				.replace("#/definitions/", "");
			const referencedSchema = defs[refPath];

			if (referencedSchema) {
				// Copy all properties from referenced schema to current schema
				Object.keys(referencedSchema).forEach((key) => {
					if (key !== "$ref") {
						schema[key] = this.deepClone(referencedSchema[key]);
					}
				});
				// Remove the $ref since we've inlined it
				delete schema.$ref;

				// Recursively resolve any refs in the inlined schema
				this.resolveRefsInline(schema, defs);
			}
		}

		// Recursively process nested schemas
		if (schema.properties) {
			Object.keys(schema.properties).forEach((key) => {
				const prop = schema.properties![key];
				if (prop) {
					this.resolveRefsInline(prop, defs);
				}
			});
		}

		if (schema.items) {
			this.resolveRefsInline(schema.items, defs);
		}

		if (schema.anyOf) {
			schema.anyOf.forEach((subSchema) => {
				this.resolveRefsInline(subSchema, defs);
			});
		}

		if (schema.oneOf) {
			(schema as any).oneOf.forEach((subSchema: JsonSchema) => {
				this.resolveRefsInline(subSchema, defs);
			});
		}

		if (schema.allOf) {
			(schema as any).allOf.forEach((subSchema: JsonSchema) => {
				this.resolveRefsInline(subSchema, defs);
			});
		}
	}

	private static optimizeSchemaRecursive(schema: JsonSchema): void {
		if (!schema || typeof schema !== "object") return;

		// Convert number to integer where appropriate
		if (schema.type === "number") {
			schema.type = "integer";
		}

		// Handle empty objects without type - add default type for OpenAI strict mode
		if (
			!schema.type &&
			typeof schema === "object" &&
			!schema.anyOf &&
			!Array.isArray(schema)
		) {
			// If it's an empty object or object without properties, make it a generic object
			if (!schema.properties || Object.keys(schema.properties).length === 0) {
				schema.type = "object";
				if (!schema.additionalProperties) {
					schema.additionalProperties = false;
				}
				if (!schema.required) {
					schema.required = [];
				}
			} else {
				// If it has properties but no type, assume it's an object
				schema.type = "object";
			}
		}

		// Special handling for z.unknown() types - OpenAI strict mode requires explicit types
		// z.unknown() typically generates empty objects without type, so we make them flexible objects
		if (
			!schema.type &&
			!schema.anyOf &&
			!schema.properties &&
			Object.keys(schema).length === 0
		) {
			schema.type = "object";
			schema.additionalProperties = true;
		}

		// Handle root level schema - add thinking to required if it exists
		if (
			schema.type === "object" &&
			schema.properties &&
			schema.properties.thinking &&
			schema.required
		) {
			if (!schema.required.includes("thinking")) {
				schema.required = ["thinking", ...schema.required];
			}
		}

		// Simplify complex anyOf structures for thinking field
		if (schema.anyOf && this.isThinkingField(schema)) {
			schema.anyOf = [{ type: "string" }, { type: "null" }];
		}

		// Handle anyOf structures
		if (schema.anyOf) {
			schema.anyOf = schema.anyOf.map((subSchema) => {
				const optimized = this.deepClone(subSchema);
				this.optimizeSchemaRecursive(optimized);
				return optimized;
			});
		}

		// Handle items in arrays
		if (schema.items) {
			this.optimizeSchemaRecursive(schema.items);
		}

		// Handle properties in objects
		if (schema.properties) {
			Object.keys(schema.properties).forEach((key) => {
				const prop = schema.properties![key];
				if (prop) {
					this.optimizeSchemaRecursive(prop);
				}
			});
		}

		// Handle special cases for empty objects with additionalProperties
		if (
			schema.type === "object" &&
			schema.properties &&
			Object.keys(schema.properties).length === 0 &&
			schema.additionalProperties === true
		) {
			// Convert to additionalProperties: false and add empty required array
			schema.additionalProperties = false;
			if (!schema.required) {
				schema.required = [];
			}
		}

		// OpenAI strict mode: when additionalProperties: false, add properties to required
		// BUT exclude empty objects (those with no properties or empty required array)
		if (
			schema.type === "object" &&
			schema.additionalProperties === false &&
			schema.properties
		) {
			const allPropertyKeys = Object.keys(schema.properties);

			// Initialize required array if it doesn't exist
			if (!schema.required) {
				schema.required = [];
			}

			// Filter out properties that are empty objects (don't require them)
			const validPropertyKeys = allPropertyKeys.filter((key) => {
				const prop = schema.properties![key];
				// Don't require empty objects or objects with no meaningful properties
				if (
					prop &&
					prop.type === "object" &&
					prop.additionalProperties === false
				) {
					return prop.properties && Object.keys(prop.properties).length > 0;
				}
				return true; // Include all other types
			});

			// Find missing required properties (only for valid ones)
			const missingRequired = validPropertyKeys.filter(
				(key) => !schema.required!.includes(key),
			);

			// Add missing properties to required array
			if (missingRequired.length > 0) {
				schema.required = [...schema.required, ...missingRequired];
			}
		}
	}

	private static isThinkingField(schema: JsonSchema): boolean {
		// Check if this looks like the complex thinking field structure
		return !!(
			schema.anyOf &&
			schema.anyOf.length > 0 &&
			schema.anyOf.some(
				(item) =>
					item?.anyOf &&
					item.anyOf.some(
						(subItem) => subItem?.not || subItem?.type === "string",
					),
			)
		);
	}

	private static reorderProperties(schema: JsonSchema): JsonSchema {
		const ordered: JsonSchema = {};

		// Preferred order for OpenAI schemas
		const propertyOrder = [
			"description",
			"type",
			"additionalProperties",
			"required",
			"properties",
			"minItems",
			"items",
			"anyOf",
			"not",
			"default",
		];

		// Add properties in preferred order
		propertyOrder.forEach((prop) => {
			if (schema.hasOwnProperty(prop)) {
				ordered[prop] = schema[prop];
			}
		});

		// Add any remaining properties
		Object.keys(schema).forEach((key) => {
			if (!propertyOrder.includes(key)) {
				ordered[key] = schema[key];
			}
		});

		// Recursively reorder nested objects
		if (ordered.properties) {
			const reorderedProperties: Record<string, JsonSchema> = {};
			Object.keys(ordered.properties).forEach((key) => {
				const prop = ordered.properties![key];
				if (prop) {
					reorderedProperties[key] = this.reorderProperties(prop);
				}
			});
			ordered.properties = reorderedProperties;
		}

		if (ordered.items) {
			ordered.items = this.reorderProperties(ordered.items);
		}

		if (ordered.anyOf) {
			ordered.anyOf = ordered.anyOf.map((subSchema) =>
				this.reorderProperties(subSchema),
			);
		}

		return ordered;
	}

	private static deepClone(obj: any): any {
		if (obj === null || typeof obj !== "object") return obj;
		if (obj instanceof Date) return new Date(obj.getTime());
		if (Array.isArray(obj)) return obj.map((item) => this.deepClone(item));

		const cloned: any = {};
		Object.keys(obj).forEach((key) => {
			cloned[key] = this.deepClone(obj[key]);
		});
		return cloned;
	}
}
