/**
 * Utilities for creating optimized JSON schemas for LLM usage
 */

interface JsonSchema {
	type?: string;
	properties?: Record<string, JsonSchema>;
	items?: JsonSchema;
	anyOf?: JsonSchema[];
	not?: JsonSchema;
	required?: string[];
	additionalProperties?: boolean;
	description?: string;
	default?: any;
	minItems?: number;
	$schema?: string;
	[key: string]: any;
}

export class SchemaOptimizer {
	/**
	 * Create the most optimized schema by flattening all $ref/$defs while preserving
	 * FULL descriptions and ALL action definitions. Also ensures OpenAI strict mode compatibility.
	 *
	 * @param model - The class/type to optimize (should have a way to generate JSON schema)
	 * @returns Optimized schema with all $refs resolved and strict mode compatibility
	 */
	static createOptimizedJsonSchema(model: any): Record<string, any> {
		// Validate input - should not be undefined or null
		if (model === undefined || model === null) {
			throw new Error(
				`--->SchemaOptimizer.createOptimizedJsonSchema() received ${model === null ? "null" : "undefined"} model. A valid class constructor is required.`,
			);
		}

		// Generate original schema - this assumes the model has a method to generate JSON schema
		// In practice, you might need to use a library like @apidevtools/json-schema-ref-parser
		// or implement your own schema generation logic
		const originalSchema = this.generateSchemaFromModel(model);
		// console.debug(
		// 	`---->SchemaOptimizer createOptimizedJsonSchema originalSchema:${JSON.stringify(
		// 		originalSchema,
		// 		null,
		// 		2,
		// 	)}`,
		// );

		// Use the conversion method to optimize the schema
		const optimizedSchema = this.convertZodToOpenAI(originalSchema);

		// console.debug(
		// 	`---->SchemaOptimizer createOptimizedJsonSchema optimizedSchema:${JSON.stringify(
		// 		optimizedSchema,
		// 		null,
		// 		2,
		// 	)}`,
		// );
		return optimizedSchema;
	}

	/**
	 * Convert Zod-generated JSON Schema to OpenAI JSON Schema format
	 * @param originalSchema - The schema generated by zod-to-json-schema
	 * @returns Optimized schema compatible with OpenAI
	 */
	static convertZodToOpenAI(originalSchema: JsonSchema): JsonSchema {
		const optimized = this.deepClone(originalSchema);

		// Remove $schema from the result (keep it at root level only)
		if (optimized.$schema) {
			delete optimized.$schema;
		}

		this.optimizeSchemaRecursive(optimized);

		// Reorder properties to match OpenAI preference
		return this.reorderProperties(optimized);
	}

	private static optimizeSchemaRecursive(schema: JsonSchema): void {
		if (!schema || typeof schema !== "object") return;

		// Convert number to integer where appropriate
		if (schema.type === "number") {
			schema.type = "integer";
		}

		// Handle empty objects without type - add default type for OpenAI strict mode
		if (
			!schema.type &&
			typeof schema === "object" &&
			!schema.anyOf &&
			!Array.isArray(schema)
		) {
			// If it's an empty object or object without properties, make it a generic object
			if (!schema.properties || Object.keys(schema.properties).length === 0) {
				schema.type = "object";
				if (!schema.additionalProperties) {
					schema.additionalProperties = false;
				}
				if (!schema.required) {
					schema.required = [];
				}
			} else {
				// If it has properties but no type, assume it's an object
				schema.type = "object";
			}
		}

		// Special handling for z.unknown() types - OpenAI strict mode requires explicit types
		// z.unknown() typically generates empty objects without type, so we make them flexible objects
		if (
			!schema.type &&
			!schema.anyOf &&
			!schema.properties &&
			Object.keys(schema).length === 0
		) {
			schema.type = "object";
			schema.additionalProperties = true;
		}

		// Handle root level schema - add thinking to required if it exists
		if (
			schema.type === "object" &&
			schema.properties &&
			schema.properties.thinking &&
			schema.required
		) {
			if (!schema.required.includes("thinking")) {
				schema.required = ["thinking", ...schema.required];
			}
		}

		// Simplify complex anyOf structures for thinking field
		if (schema.anyOf && this.isThinkingField(schema)) {
			schema.anyOf = [{ type: "string" }, { type: "null" }];
		}

		// Handle anyOf structures
		if (schema.anyOf) {
			schema.anyOf = schema.anyOf.map((subSchema) => {
				const optimized = this.deepClone(subSchema);
				this.optimizeSchemaRecursive(optimized);
				return optimized;
			});
		}

		// Handle items in arrays
		if (schema.items) {
			this.optimizeSchemaRecursive(schema.items);
		}

		// Handle properties in objects
		if (schema.properties) {
			Object.keys(schema.properties).forEach((key) => {
				const prop = schema.properties![key];
				if (prop) {
					this.optimizeSchemaRecursive(prop);
				}
			});
		}

		// Handle special cases for empty objects with additionalProperties
		if (
			schema.type === "object" &&
			schema.properties &&
			Object.keys(schema.properties).length === 0 &&
			schema.additionalProperties === true
		) {
			// Convert to additionalProperties: false and add empty required array
			schema.additionalProperties = false;
			if (!schema.required) {
				schema.required = [];
			}
		}

		// OpenAI strict mode: when additionalProperties: false, add properties to required
		// BUT exclude empty objects (those with no properties or empty required array)
		if (
			schema.type === "object" &&
			schema.additionalProperties === false &&
			schema.properties
		) {
			const allPropertyKeys = Object.keys(schema.properties);

			// Initialize required array if it doesn't exist
			if (!schema.required) {
				schema.required = [];
			}

			// Filter out properties that are empty objects (don't require them)
			const validPropertyKeys = allPropertyKeys.filter((key) => {
				const prop = schema.properties![key];
				// Don't require empty objects or objects with no meaningful properties
				if (
					prop &&
					prop.type === "object" &&
					prop.additionalProperties === false
				) {
					return prop.properties && Object.keys(prop.properties).length > 0;
				}
				return true; // Include all other types
			});

			// Find missing required properties (only for valid ones)
			const missingRequired = validPropertyKeys.filter(
				(key) => !schema.required!.includes(key),
			);

			// Add missing properties to required array
			if (missingRequired.length > 0) {
				schema.required = [...schema.required, ...missingRequired];
			}
		}
	}

	private static isThinkingField(schema: JsonSchema): boolean {
		// Check if this looks like the complex thinking field structure
		return !!(
			schema.anyOf &&
			schema.anyOf.length > 0 &&
			schema.anyOf.some(
				(item) =>
					item?.anyOf &&
					item.anyOf.some(
						(subItem) => subItem?.not || subItem?.type === "string",
					),
			)
		);
	}

	private static reorderProperties(schema: JsonSchema): JsonSchema {
		const ordered: JsonSchema = {};

		// Preferred order for OpenAI schemas
		const propertyOrder = [
			"description",
			"type",
			"additionalProperties",
			"required",
			"properties",
			"minItems",
			"items",
			"anyOf",
			"not",
			"default",
		];

		// Add properties in preferred order
		propertyOrder.forEach((prop) => {
			if (schema.hasOwnProperty(prop)) {
				ordered[prop] = schema[prop];
			}
		});

		// Add any remaining properties
		Object.keys(schema).forEach((key) => {
			if (!propertyOrder.includes(key)) {
				ordered[key] = schema[key];
			}
		});

		// Recursively reorder nested objects
		if (ordered.properties) {
			const reorderedProperties: Record<string, JsonSchema> = {};
			Object.keys(ordered.properties).forEach((key) => {
				const prop = ordered.properties![key];
				if (prop) {
					reorderedProperties[key] = this.reorderProperties(prop);
				}
			});
			ordered.properties = reorderedProperties;
		}

		if (ordered.items) {
			ordered.items = this.reorderProperties(ordered.items);
		}

		if (ordered.anyOf) {
			ordered.anyOf = ordered.anyOf.map((subSchema) =>
				this.reorderProperties(subSchema),
			);
		}

		return ordered;
	}

	private static deepClone(obj: any): any {
		if (obj === null || typeof obj !== "object") return obj;
		if (obj instanceof Date) return new Date(obj.getTime());
		if (Array.isArray(obj)) return obj.map((item) => this.deepClone(item));

		const cloned: any = {};
		Object.keys(obj).forEach((key) => {
			cloned[key] = this.deepClone(obj[key]);
		});
		return cloned;
	}

	/**
	 * Generate a JSON schema from a model/type
	 * This is a placeholder implementation - in practice you'd use a proper schema generation library
	 */
	private static generateSchemaFromModel(model: any): Record<string, any> {
		// Validate input
		if (model === undefined || model === null) {
			throw new Error(
				`--->generateSchemaFromModel() received ${model === null ? "null" : "undefined"} model. Cannot generate schema from invalid input.`,
			);
		}

		// This is a simplified implementation
		// In practice, you'd integrate with libraries like:
		// - @apidevtools/json-schema-ref-parser
		// - typescript-json-schema
		// - Or use runtime type information from decorators/metadata

		if (typeof model === "function" && model.getJsonSchema) {
			return model.getJsonSchema();
		}

		if (typeof model === "object" && model.schema) {
			return model.schema;
		}
		// Fallback to basic object schema
		// return {
		//   type: "object",
		//   properties: {},
		//   required: [],
		//   additionalProperties: false,
		// };
		// If we reach here, the model doesn't have expected schema generation capabilities
		throw new Error(
			`--->generateSchemaFromModel() received invalid model type: ${typeof model}. Expected a class constructor with getJsonSchema method or an object with schema property.`,
		);
	}
}
