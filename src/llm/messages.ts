// Helper functions
function truncate(text: string, maxLength: number = 50): string {
	if (text.length <= maxLength) {
		return text;
	}
	return text.substring(0, maxLength - 3) + "...";
}

function formatImageUrl(url: string, maxLength: number = 50): string {
	if (url.startsWith("data:")) {
		// Base64 image
		const parts = url.split(";");
		const mediaType =
			parts.length > 0 && parts[0] && parts[0].includes(":")
				? parts[0].split(":")[1] || "image"
				: "image";
		return `<base64 ${mediaType}>`;
	} else {
		// Regular URL
		return truncate(url, maxLength);
	}
}

// Content part types
export interface ContentPartTextParam {
	text: string;
	type: "text";
}

export interface ContentPartRefusalParam {
	refusal: string;
	type: "refusal";
}

export type SupportedImageMediaType =
	| "image/jpeg"
	| "image/png"
	| "image/gif"
	| "image/webp";

export interface ImageURL {
	/** Either a URL of the image or the base64 encoded image data */
	url: string;

	/** Specifies the detail level of the image */
	detail: "auto" | "low" | "high";

	/** Media type - needed for Anthropic */
	mediaType: SupportedImageMediaType;

	toString(): string;
}

export interface ContentPartImageParam {
	imageUrl: ImageURL;
	type: "image_url";
}

export interface Function {
	/** The arguments to call the function with, as generated by the model in JSON format */
	arguments: string;

	/** The name of the function to call */
	name: string;
}

export interface ToolCall {
	/** The ID of the tool call */
	id: string;

	/** The function that the model called */
	function: Function;

	/** The type of the tool. Currently, only `function` is supported */
	type: "function";
}

// Message base interface
interface MessageBase {
	role: "user" | "system" | "assistant";

	/** Whether to cache this message. This is only applicable when using Anthropic models */
	cache?: boolean;
}

// Message types
export interface UserMessage extends MessageBase {
	role: "user";

	/** The contents of the user message */
	content: string | Array<ContentPartTextParam | ContentPartImageParam>;

	/** An optional name for the participant */
	name?: string | null;
}

export interface SystemMessage extends MessageBase {
	role: "system";

	/** The contents of the system message */
	content: string | ContentPartTextParam[];

	name?: string | null;
}

export interface AssistantMessage extends MessageBase {
	role: "assistant";

	/** The contents of the assistant message */
	content:
		| string
		| Array<ContentPartTextParam | ContentPartRefusalParam>
		| null;

	name?: string | null;

	/** The refusal message by the assistant */
	refusal?: string | null;

	/** The tool calls generated by the model, such as function calls */
	toolCalls?: ToolCall[];
}

// Union type for all message types
export type BaseMessage = UserMessage | SystemMessage | AssistantMessage;

// Factory functions with toString methods and text properties

export function createContentPartText(
	text: string,
): ContentPartTextParam & { toString(): string } {
	return {
		text,
		type: "text",
		toString() {
			return `Text: ${truncate(this.text)}`;
		},
	};
}

export function createContentPartRefusal(
	refusal: string,
): ContentPartRefusalParam & { toString(): string } {
	return {
		refusal,
		type: "refusal",
		toString() {
			return `Refusal: ${truncate(this.refusal)}`;
		},
	};
}

export function createImageURL(
	url: string,
	detail: "auto" | "low" | "high" = "auto",
	mediaType: SupportedImageMediaType = "image/png",
): ImageURL {
	return {
		url,
		detail,
		mediaType,
		toString() {
			const urlDisplay = formatImageUrl(this.url);
			return `üñºÔ∏è  Image[${this.mediaType}, detail=${this.detail}]: ${urlDisplay}`;
		},
	};
}

export function createContentPartImage(
	imageUrl: ImageURL,
): ContentPartImageParam & { toString(): string } {
	return {
		imageUrl,
		type: "image_url",
		toString() {
			return this.imageUrl.toString();
		},
	};
}

export function createFunction(
	name: string,
	args: string,
): Function & { toString(): string } {
	return {
		name,
		arguments: args,
		toString() {
			const argsPreview = truncate(this.arguments, 80);
			return `${this.name}(${argsPreview})`;
		},
	};
}

export function createToolCall(
	id: string,
	func: Function,
): ToolCall & { toString(): string } {
	return {
		id,
		function: func,
		type: "function",
		toString() {
			const funcStr =
				"toString" in this.function
					? this.function.toString()
					: `${(this.function as Function).name}(...)`;
			return `ToolCall[${this.id}]: ${funcStr}`;
		},
	};
}

// Helper functions to extract text from messages
export function getMessageText(message: BaseMessage): string {
	if (typeof message.content === "string") {
		return message.content;
	} else if (Array.isArray(message.content)) {
		let text = "";
		for (const part of message.content) {
			if (part.type === "text") {
				text += part.text;
			} else if ("refusal" in part && part.type === "refusal") {
				text += `[Refusal] ${part.refusal}`;
			}
		}
		return text;
	}
	return "";
}

// Message factory functions with text property and toString methods
export function createUserMessage(
	content: string | Array<ContentPartTextParam | ContentPartImageParam>,
	name?: string | null,
	cache: boolean = false,
): UserMessage & { text: string; toString(): string } {
	const message: UserMessage = {
		role: "user",
		content,
		name,
		cache,
	};

	return {
		...message,
		get text() {
			return getMessageText(this);
		},
		toString() {
			return `UserMessage(content=${this.text})`;
		},
	};
}

export function createSystemMessage(
	content: string | ContentPartTextParam[],
	name?: string | null,
	cache: boolean = false,
): SystemMessage & { text: string; toString(): string } {
	const message: SystemMessage = {
		role: "system",
		content,
		name,
		cache,
	};

	return {
		...message,
		get text() {
			return getMessageText(this);
		},
		toString() {
			return `SystemMessage(content=${this.text})`;
		},
	};
}

export function createAssistantMessage(
	content:
		| string
		| Array<ContentPartTextParam | ContentPartRefusalParam>
		| null = null,
	name?: string | null,
	refusal?: string | null,
	toolCalls?: ToolCall[],
	cache: boolean = false,
): AssistantMessage & { text: string; toString(): string } {
	const message: AssistantMessage = {
		role: "assistant",
		content,
		name,
		refusal,
		toolCalls,
		cache,
	};

	return {
		...message,
		get text() {
			return getMessageText(this);
		},
		toString() {
			return `AssistantMessage(content=${this.text})`;
		},
	};
}

// Better named exports for content parts
export type ContentText = ContentPartTextParam;
export type ContentRefusal = ContentPartRefusalParam;
export type ContentImage = ContentPartImageParam;
